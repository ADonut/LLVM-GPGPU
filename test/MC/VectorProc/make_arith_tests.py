import random, sys

print '# RUN: llvm-mc -arch=vectorproc -show-encoding %s | FileCheck %s'
print '# This file auto-generated by ' + sys.argv[0]

def make_encoding(x):
	str = ' ; CHECK: encoding: ['
	for y in range(4):
		if y != 0:
			str += ','
			
		str += '0x%02x' % (x & 0xff)
		x >>= 8

	return str + ']'

def make_a_instruction(fmt, opcode, dest, src1, src2, mask):
	return make_encoding((6 << 29) | (fmt << 26) | (opcode << 20) | (src2 << 15) 
		| (mask << 10) | (dest << 5) | src1)

def make_b_instruction(fmt, opcode, dest, src1, imm, mask):
	return make_encoding((fmt << 28) | (opcode << 23) | (imm << 15) 
		| (mask << 10) | (dest << 5) | src1)

def make_bprime_instruction(fmt, opcode, dest, src1, imm):
	return make_encoding((fmt << 28) | (opcode << 23) | (imm << 10) 
		| (dest << 5) | src1)

binaryOps = [
	(0, 'or'),
	(1, 'and'),
	(3, 'xor'),
	(5, 'add.i'),
	(6, 'sub.i'),
	(7, 'mul.i'),
	# Not implemented (8, 'div.i')
	(9, 'ashr'),
	(10, 'shr'),
	(11, 'shl'),
	(0x20, 'add.f'),
	(0x21, 'sub.f'),
	(0x22, 'mul.f'),
]

print '\n\t;\n\t; Arithmetic\n\t;\n'

for opcode, mnemonic in binaryOps:
	for aFormat in [ 0, 1, 2, 4, 5 ]:
		rega = random.randint(0, 27)
		regb = random.randint(0, 27)
		regc = random.randint(0, 27)
		regm = random.randint(0, 27)

		if aFormat == 0:
			# scalar/scalar/scalar
			print '\t' + mnemonic + ' s' + str(rega) + ', s' + str(regb) + ', s' + str(regc) \
				+ make_a_instruction(aFormat, opcode, rega, regb, regc, 0)
		elif aFormat == 1:
			# vector/vector/scalar
			print '\t' + mnemonic + ' v' + str(rega) + ', v' + str(regb) + ', s' + str(regc) \
				+ make_a_instruction(aFormat, opcode, rega, regb, regc, 0)
		elif aFormat == 2:
			# vector/vector/scalar masked
			print '\t' + mnemonic + '.mask v' + str(rega) + ', s' + str(regm) + ', v' + str(regb) + ', s' + str(regc) \
				+  make_a_instruction(aFormat, opcode, rega, regb, regc, regm)
		elif aFormat == 4:
			# vector/vector/vector		
			print '\t' + mnemonic + ' v' + str(rega) + ', v' + str(regb) + ', v' + str(regc) \
				+  make_a_instruction(aFormat, opcode, rega, regb, regc, 0)
		elif aFormat == 5:
			# vector/vector/vector masked
			print '\t' + mnemonic + '.mask v' + str(rega) + ', s' + str(regm) + ', v' + str(regb) + ', v' + str(regc) \
				+ make_a_instruction(aFormat, opcode, rega, regb, regc, regm)

	if mnemonic[-2:] == '.f':
		continue	# Can't do immediate for FP instructions

	for bFormat in [ 0, 1, 2, 4, 5 ]:
		imm = random.randint(0, 255)
		if bFormat == 0:
			# scalar/scalar
			print '\t' + mnemonic + ' s' + str(rega) + ', s' + str(regb) + ', ' + str(imm) \
				+ make_bprime_instruction(bFormat, opcode, rega, regb, imm)
		elif bFormat == 1:
			# vector/vector
			print '\t' + mnemonic + ' v' + str(rega) + ', v' + str(regb) + ', ' + str(imm) \
				+ make_bprime_instruction(bFormat, opcode, rega, regb, imm)
		elif bFormat == 2:
			# vector/vector masked
			print '\t' + mnemonic + '.mask v' + str(rega) + ', s' + str(regm) + ', v' + str(regb) + ', ' + str(imm) \
				+ make_b_instruction(bFormat, opcode, rega, regb, imm, regm)
		elif bFormat == 4:
			# vector/scalar
			print '\t' + mnemonic + ' v' + str(rega) + ', s' + str(regb) + ', ' + str(imm) \
				+ make_bprime_instruction(bFormat, opcode, rega, regb, imm)
		elif bFormat == 5:
			# vector/scalar masked
			print '\t' + mnemonic + '.mask v' + str(rega) + ', s' + str(regm) + ', s' + str(regb) + ', ' + str(imm) \
				+ make_b_instruction(bFormat, opcode, rega, regb, imm, regm)

unaryOps = [
	(12, 'clz'),
	(14, 'ctz'),
	(0xf, 'move'),
#	(0x1b, 'ftoi'),
#	(0x1c, 'recip'),
#	(0x1d, 'sext.8'),
#	(0x1e, 'sext.16'),
#	(0x2a, 'itof')
]

for opcode, mnemonic in unaryOps:
	for aFormat in [ 0, 1, 2, 4, 5 ]:
		rega = random.randint(0, 27)
		regb = random.randint(0, 27)
		regm = random.randint(0, 27)

		if aFormat == 0:
			# Scalar/Scalar
			print '\t' + mnemonic + ' s' + str(rega) + ', s' + str(regb) \
				+ make_a_instruction(aFormat, opcode, rega, 0, regb, 0)
		elif aFormat == 1:
			# Vector/Scalar
			print '\t' + mnemonic + ' v' + str(rega) + ', s' + str(regb) \
				+ make_a_instruction(aFormat, opcode, rega, 0, regb, 0)
		elif aFormat == 2:
			# Vector/Scalar Masked
			print '\t' + mnemonic + '.mask v' + str(rega) + ', s' + str(regm) + ', s' + str(regb) \
				+ make_a_instruction(aFormat, opcode, rega, 0, regb, regm)
		elif aFormat == 4:
			# Vector/Vector
			print '\t' + mnemonic + ' v' + str(rega) + ', v' + str(regb) \
				+ make_a_instruction(aFormat, opcode, rega, 0, regb, 0)
		elif aFormat == 5:
			# Vector/Vector masked	
			print '\t' + mnemonic + '.mask v' + str(rega) + ', s' + str(regm) + ', v' \
				+ str(regb) + make_a_instruction(aFormat, opcode, rega, 0, regb, regm)

print '\tshuffle v1, v2, v3' + make_a_instruction(4, 0xd, 1, 2, 3, 0)

# XXX shuffle.mask should be supported, but isn't by compiler

print '\tgetfield s4, v5, s6' + make_a_instruction(1, 0x1a, 4, 5, 6, 0)

# getfield with an immediate param should be supported, but isn't by compiler

cmpOps = [
	(0x12, 'gt.i'),
	(0x13, 'ge.i'),
	(0x14, 'lt.i'),
	(0x15, 'le.i'),
	(0x16, 'gt.u'),
	(0x17, 'ge.u'),
	(0x18, 'lt.u'),
	(0x19, 'le.u'),
	(0x2c, 'gt.f'),
	(0x2d, 'ge.f'),
	(0x2e, 'lt.f'),
	(0x2f, 'le.f')
]

print '\n\t;\n\t; Comparisons\n\t;\n'
for opcode, mnemonic in cmpOps:
	for aFormat in [ 0, 1, 4 ]:
		if aFormat == 0:
			print '\tset' + mnemonic +  ' s' + str(rega) + ', s' + str(regb) + ', s' + str(regc) \
				+ make_a_instruction(aFormat, opcode, rega, regb, regc, 0)
		elif aFormat == 1:	
			print '\tset' + mnemonic + ' s' + str(rega) + ', v' + str(regb) + ', s' + str(regc) \
				+ make_a_instruction(aFormat, opcode, rega, regb, regc, 0)
		elif aFormat == 4:
			print '\tset' + mnemonic + ' s' + str(rega) + ', v' + str(regb) + ', v' + str(regc) \
				+ make_a_instruction(aFormat, opcode, rega, regb, regc, 0)

	if mnemonic[-2:] == '.f':
		continue	# Can't do immediate for FP instructions
			
	for bFormat in [ 0, 1 ]:
		imm = random.randint(0, 255)
		if bFormat == 0:
			print '\tset' + mnemonic +  ' s' + str(rega) + ', s' + str(regb) + ', ' + str(imm) \
				+ make_bprime_instruction(bFormat, opcode, rega, regb, imm)
		elif bFormat == 1:	
			print '\tset' + mnemonic + ' s' + str(rega) + ', v' + str(regb) + ', ' + str(imm) \
				+ make_bprime_instruction(bFormat, opcode, rega, regb, imm)
	
	
print '\n\t;\n\t; getfield\n\t;\n'
print '\tgetfield s1, v2, s3 ' + make_a_instruction(1, 0x1a, 1, 2, 3, 0)

	