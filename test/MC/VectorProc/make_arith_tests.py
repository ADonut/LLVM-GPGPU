import random, sys

print '# RUN: llvm-mc -arch=vectorproc -show-encoding %s | FileCheck %s'
print '# This file auto-generated by ' + sys.argv[0]

def make_encoding(x):
	str = ' ; CHECK: encoding: ['
	for y in range(4):
		if y != 0:
			str += ','
			
		str += '0x%02x' % (x & 0xff)
		x >>= 8

	return str + ']'

def make_a_instruction(fmt, opcode, dest, src1, src2, mask):
	return make_encoding((6 << 29) | (fmt << 26) | (opcode << 20) | (src2 << 15) 
		| (mask << 10) | (dest << 5) | src1)

def make_b_instruction(fmt, opcode, dest, src1, imm, mask):
	return make_encoding((fmt << 28) | (opcode << 23) | (imm << 15) 
		| (mask << 10) | (dest << 5) | src1)

def make_bprime_instruction(fmt, opcode, dest, src1, imm):
	return make_encoding((fmt << 28) | (opcode << 23) | (imm << 10) 
		| (dest << 5) | src1)

binaryOps = [
	(0, 'or'),
	(1, 'and'),
	# Not implemented (2, 'uminus')
	(3, 'xor'),
	# Not implemented (4, 'not')
	(5, 'add.i'),
	(6, 'sub.i'),
	(7, 'mul.i'),
	# Not implemented (8, 'div.i')
	(9, 'ashr'),
	(10, 'shr'),
	(11, 'shl'),
	(0x20, 'add.f'),
	(0x21, 'sub.f'),
	(0x22, 'mul.f'),
]

print '\n\t;\n\t; Arithmetic\n\t;\n'

for opcode, mnemonic in binaryOps:
	for aFormat in [ 0, 1, 2, 4, 5 ]:
		rega = random.randint(0, 27)
		regb = random.randint(0, 27)
		regc = random.randint(0, 27)
		regm = random.randint(0, 27)

		if aFormat == 0:
			# scalar/scalar/scalar
			print '\t' + mnemonic + ' s' + str(rega) + ', s' + str(regb) + ', s' + str(regc) \
				+ make_a_instruction(aFormat, opcode, rega, regb, regc, 0)
		elif aFormat == 1:
			# vector/vector/scalar
			print '\t' + mnemonic + ' v' + str(rega) + ', v' + str(regb) + ', s' + str(regc) \
				+ make_a_instruction(aFormat, opcode, rega, regb, regc, 0)
		elif aFormat == 2:
			# vector/vector/scalar masked
			print '\t' + mnemonic + '.mask v' + str(rega) + ', s' + str(regm) + ', v' + str(regb) + ', s' + str(regc) \
				+  make_a_instruction(aFormat, opcode, rega, regb, regc, regm)
		elif aFormat == 4:
			# vector/vector/vector		
			print '\t' + mnemonic + ' v' + str(rega) + ', v' + str(regb) + ', v' + str(regc) \
				+  make_a_instruction(aFormat, opcode, rega, regb, regc, 0)
		elif aFormat == 5:
			# vector/vector/vector masked
			print '\t' + mnemonic + '.mask v' + str(rega) + ', s' + str(regm) + ', v' + str(regb) + ', v' + str(regc) \
				+ make_a_instruction(aFormat, opcode, rega, regb, regc, regm)

	if mnemonic[-2:] == '.f':
		continue	# Can't do immediate for FP instructions

	for bFormat in [ 0, 1, 2, 4, 5 ]:
		imm = random.randint(0, 255)
		if bFormat == 0:
			# scalar/scalar
			print '\t' + mnemonic + ' s' + str(rega) + ', s' + str(regb) + ', ' + str(imm) \
				+ make_bprime_instruction(bFormat, opcode, rega, regb, imm)
		elif bFormat == 1:
			# vector/vector
			print '\t' + mnemonic + ' v' + str(rega) + ', v' + str(regb) + ', ' + str(imm) \
				+ make_bprime_instruction(bFormat, opcode, rega, regb, imm)
		elif bFormat == 2:
			# vector/vector masked
			print '\t' + mnemonic + '.mask v' + str(rega) + ', s' + str(regm) + ', v' + str(regb) + ', ' + str(imm) \
				+ make_b_instruction(bFormat, opcode, rega, regb, imm, regm)
		elif bFormat == 4:
			# vector/scalar
			print '\t' + mnemonic + ' v' + str(rega) + ', s' + str(regb) + ', ' + str(imm) \
				+ make_bprime_instruction(bFormat, opcode, rega, regb, imm)
		elif bFormat == 5:
			# vector/scalar masked
			print '\t' + mnemonic + '.mask v' + str(rega) + ', s' + str(regm) + ', s' + str(regb) + ', ' + str(imm) \
				+ make_b_instruction(bFormat, opcode, rega, regb, imm, regm)

# XXX add test for unary ops

cmpOps = [
	(0x12, 'gt.i'),
	(0x13, 'ge.i'),
	(0x14, 'lt.i'),
	(0x15, 'le.i'),
	(0x16, 'gt.u'),
	(0x17, 'ge.u'),
	(0x18, 'lt.u'),
	(0x19, 'le.u'),
	(0x2c, 'gt.f'),
	(0x2d, 'ge.f'),
	(0x2e, 'lt.f'),
	(0x2f, 'le.f')
]

print '\n\t;\n\t; Comparisons\n\t;\n'
for opcode, mnemonic in cmpOps:
	for aFormat in [ 0, 1, 4 ]:
		if aFormat == 0:
			print '\tset' + mnemonic +  ' s' + str(rega) + ', s' + str(regb) + ', s' + str(regc) \
				+ make_a_instruction(aFormat, opcode, rega, regb, regc, 0)
		elif aFormat == 1:	
			print '\tset' + mnemonic + ' s' + str(rega) + ', v' + str(regb) + ', s' + str(regc) \
				+ make_a_instruction(aFormat, opcode, rega, regb, regc, 0)
		elif aFormat == 4:
			print '\tset' + mnemonic + ' s' + str(rega) + ', v' + str(regb) + ', v' + str(regc) \
				+ make_a_instruction(aFormat, opcode, rega, regb, regc, 0)

	if mnemonic[-2:] == '.f':
		continue	# Can't do immediate for FP instructions
			
	for bFormat in [ 0, 1 ]:
		imm = random.randint(0, 255)
		if bFormat == 0:
			print '\tset' + mnemonic +  ' s' + str(rega) + ', s' + str(regb) + ', ' + str(imm) \
				+ make_bprime_instruction(bFormat, opcode, rega, regb, imm)
		elif bFormat == 1:	
			print '\tset' + mnemonic + ' s' + str(rega) + ', v' + str(regb) + ', ' + str(imm) \
				+ make_bprime_instruction(bFormat, opcode, rega, regb, imm)
	
	
	